import { Injectable } from '@nestjs/common';
import { PinoLogger } from 'nestjs-pino';

import { PrismaService } from '@/shared/application/services';
import { RefreshTokenEntity } from '../../domain/entities';
import { RefreshTokenRepository } from '../../domain/repositories';
import { RefreshTokenUpdateData } from '../../domain/types';

/**
 * Prisma adapter for refresh token persistence.
 *
 * This class implements the `RefreshTokenRepository` interface using Prisma to interact
 * with the database. It is responsible for all CRUD operations and data transformations
 * between the domain `RefreshTokenEntity` and the Prisma data model.
 */
@Injectable()
export class RefreshTokenPrismaAdapter implements RefreshTokenRepository {
  constructor(
    private readonly prisma: PrismaService,
    private readonly logger: PinoLogger,
  ) {
    this.logger.setContext(RefreshTokenPrismaAdapter.name);
  }

  /**
   * Generates a new, unique identifier (UUID) for a refresh token using the database.
   *
   * This implementation leverages the database's `gen_random_uuid()` function to ensure
   * that the ID is generated by the same source that guarantees its uniqueness.
   *
   * @returns A promise that resolves to a unique identifier string.
   * @throws An error if the database fails to generate an ID.
   */
  async generateId(): Promise<string> {
    this.logger.assign({ method: 'generateId' });
    try {
      const result = await this.prisma.$queryRaw<{ id: string }[]>`SELECT gen_random_uuid() AS id`;
      const id = result[0].id;
      this.logger.info('Successfully generated new refresh token ID from database');
      return id;
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to generate refresh token ID from database');
      throw new Error('Failed to generate refresh token ID.');
    }
  }

  /**
   * Persists a new refresh token entity to the database.
   *
   * It first converts the `RefreshTokenEntity` to a persistence-ready format and then
   * uses Prisma's `create` method to save it.
   *
   * @param refreshToken The `RefreshTokenEntity` instance to create.
   * @returns A promise that resolves to the created `RefreshTokenEntity`.
   * @throws An error if the database operation fails.
   */
  async create(refreshToken: RefreshTokenEntity): Promise<RefreshTokenEntity> {
    this.logger.assign({ method: 'create' });
    try {
      const data = refreshToken.toPersistence();

      const createdToken = await this.prisma.refreshToken.create({
        data,
      });

      this.logger.info('Successfully created refresh token');
      return RefreshTokenEntity.fromPersistence(createdToken);
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to create refresh token');
      throw new Error('Failed to create refresh token.');
    }
  }

  /**
   * Finds a refresh token by its unique identifier.
   *
   * @param id The unique identifier of the refresh token.
   * @returns A promise that resolves to the `RefreshTokenEntity` if found, otherwise `null`.
   * @throws An error if the database operation fails.
   */
  async findById(id: string): Promise<RefreshTokenEntity | null> {
    this.logger.assign({ method: 'findById', id });
    try {
      const refreshToken = await this.prisma.refreshToken.findUnique({
        where: { id },
      });

      if (!refreshToken) {
        this.logger.warn('Refresh token not found');
        return null;
      }

      this.logger.info('Successfully found refresh token by ID');
      return RefreshTokenEntity.fromPersistence(refreshToken);
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to find refresh token by ID');
      throw new Error('Failed to find refresh token by ID.');
    }
  }

  /**
   * Finds a refresh token by its token hash.
   *
   * @param tokenHash The SHA-256 hash of the refresh token.
   * @returns A promise that resolves to the `RefreshTokenEntity` if found, otherwise `null`.
   * @throws An error if the database operation fails.
   */
  async findByTokenHash(tokenHash: string): Promise<RefreshTokenEntity | null> {
    this.logger.assign({ method: 'findByTokenHash' });
    try {
      const refreshToken = await this.prisma.refreshToken.findUnique({
        where: { tokenHash },
      });

      if (!refreshToken) {
        this.logger.warn('Refresh token not found by hash');
        return null;
      }

      this.logger.info('Successfully found refresh token by hash');
      return RefreshTokenEntity.fromPersistence(refreshToken);
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to find refresh token by token hash');
      throw new Error('Failed to find refresh token by token hash.');
    }
  }

  /**
   * Retrieves all refresh tokens associated with a specific user.
   *
   * @param userId The unique identifier of the user.
   * @returns A promise that resolves to an array of `RefreshTokenEntity` instances.
   * @throws An error if the database operation fails.
   */
  async findByUserId(userId: string): Promise<RefreshTokenEntity[]> {
    this.logger.assign({ method: 'findByUserId', userId });
    try {
      const tokens = await this.prisma.refreshToken.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
      });

      this.logger.info(`Found ${tokens.length} tokens for the user`);
      return tokens.map(token => RefreshTokenEntity.fromPersistence(token));
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to find refresh tokens by user ID');
      throw new Error('Failed to find refresh tokens by user ID.');
    }
  }

  /**
   * Updates an existing refresh token, typically to revoke it.
   *
   * @param params An object containing the token `id` and the `revokedAt` date.
   * @returns A promise that resolves to the updated `RefreshTokenEntity`.
   * @throws An error if the database operation fails.
   */
  async update(params: RefreshTokenUpdateData): Promise<RefreshTokenEntity> {
    this.logger.assign({ method: 'update', id: params.id });
    try {
      const updatedToken = await this.prisma.refreshToken.update({
        where: { id: params.id },
        data: { revokedAt: params.revokedAt },
      });

      this.logger.info('Successfully updated refresh token');
      return RefreshTokenEntity.fromPersistence(updatedToken);
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to update refresh token');
      throw new Error('Failed to update refresh token.');
    }
  }

  /**
   * Revokes all active refresh tokens for a specific user.
   *
   * This method sets the `revokedAt` field to the current time for all tokens
   * belonging to the user that have not already been revoked.
   *
   * @param userId The unique identifier of the user.
   * @returns A promise that resolves to the number of tokens that were revoked.
   * @throws An error if the database operation fails.
   */
  async revokeAllByUserId(userId: string): Promise<number> {
    this.logger.assign({ method: 'revokeAllByUserId', userId });
    try {
      const result = await this.prisma.refreshToken.updateMany({
        where: {
          userId,
          revokedAt: null,
        },
        data: {
          revokedAt: new Date(),
        },
      });

      this.logger.info(`Successfully revoked ${result.count} tokens`);
      return result.count;
    } catch (error: unknown) {
      this.logger.error({ error }, 'Failed to revoke all refresh tokens for user');
      throw new Error('Failed to revoke all refresh tokens for user.');
    }
  }
}
